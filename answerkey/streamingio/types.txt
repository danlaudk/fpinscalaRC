Free[F[_],A] extends Free[F, A]
  case class Suspend[F[_],A](s: F[A])
  case class FlatMap[F[_],A,B](s: Free[F, A],
                               f: A => Free[F, B]) 

def freeMonad[F[_]] = new Monad[({type f[a] = Free[F,a]})#f] {...}

 @annotation.tailrec
def runTrampoline[A](a: Free[Function0,A]): A
def run[F[_],A](a: Free[F,A])(implicit F: Monad[F]): F[A]

trait Translate[F[_], G[_]] { def apply[A](f: F[A]): G[A] }

  type ~>[F[_], G[_]] = Translate[F,G] // gives us infix syntax `F ~> G` for `Translate[F,G]`

  implicit val function0Monad = new Monad[Function0] {
    def unit[A](a: => A) = () => a
    def flatMap[A,B](a: Function0[A])(f: A => Function0[B]) =
      () => f(a())()
  }

  implicit val parMonad = new Monad[Par] {
    def unit[A](a: => A) = Par.unit(a)
    def flatMap[A,B](a: Par[A])(f: A => Par[B]) = Par.fork { Par.flatMap(a)(f) }
  }

def runFree[F[_],G[_],A](free: Free[F,A])(t: F ~> G)(
                           implicit G: Monad[G]): G[A] =    step(free) match {}

val consoleToPar: Console ~> Par
val consoleToFunction0 =   new (Console ~> Function0) { def apply[A](a: Console[A]) = a.toThunk }

def runConsoleFunction0[A](a: Free[Console,A]): () => A =
runFree[Console,Function0,A](a)(consoleToFunction0)
def runConsolePar[A](a: Free[Console,A]): Par[A] =
runFree[Console,Par,A](a)(consoleToPar)

def translate[F[_],G[_],A](f: Free[F,A])(fg: F ~> G): Free[G,A] = runFree(f)(t)(freeMonad[G]) // t:(F ~> FreeG)
//from 15
Process -Emit(O,Halt[I,O])
        -Await(Option[I] => Process[I,O])
        -Halt()
    apply(Stream[I]) : Stream[O] // by deconstructing head tail and the field defns of Process[I,O]

def repeat: Process[I,O] //used to lift a f into a Process[I,O] , by using a recursive call

//eg. 
sum:Process[Dbl,Dbl] = Await{ Process[I,O]}  // by recursive calls on accumulated running total
take:Process[I,I] = Await{ Process[I,O]} 

// 
def emit[I,O] = Emit(head:O, Halt[I,O]())
def id[I]: Process[I,I] = lift(identity) // 
